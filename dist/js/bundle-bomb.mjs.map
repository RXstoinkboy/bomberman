{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/js/Board.mjs","webpack:///./src/js/Bomb.mjs","webpack:///./src/js/Characters.mjs","webpack:///./src/js/VAR.mjs","webpack:///./src/js/index.mjs"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAA8B;AACG;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+BAA+B;AAC7C,UAAU,+BAA+B;AACzC,UAAU,+BAA+B;AACzC,YAAY,6BAA6B;AACzC;AACO;AACP;AACA;AACA,gCAAgC,4CAAG,0CAA0C;AAC7E;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;;AAEA,sCAAsC;AACtC,0BAA0B;AAC1B;;AAEA,oBAAoB,kBAAkB,MAAM;AAC5C,wBAAwB;AACxB,wBAAwB,oBAAoB,MAAM;AAClD;AACA,mGAAmG;;AAEnG;AACA,uCAAuC,WAAW,E;AAClD;AACA;AACA;AACA,uBAAuB,4CAAG,2BAA2B;AACrD;;AAEA,6C;AACA;AACA;;AAEA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,mBAAmB,MAAM;;AAEzC,gBAAgB,uBAAuB,MAAM;AAC7C,IAAI,+CAAI;AACR,QAAQ,+CAAI;AACZ;AACA;AACA;A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","file":"bundle-bomb.mjs","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/js/Bomb.mjs\");\n","import {VAR} from './VAR.mjs';\r\nimport {Game} from './index.mjs';\r\n\r\nBoard.templates = [ // creating board templates here\r\n    [\r\n        'WWWWWWWWWWWWWWW',\r\n        'W             W',\r\n        'W X X X X X X W',\r\n        'W             W',\r\n        'W X X X X X X W',\r\n        'W             W',\r\n        'W X X X X X X W',\r\n        'W             W',\r\n        'W X X X X X X W',\r\n        'W             W',\r\n        'WWWWWWWWWWWWWWW'\r\n    ],\r\n    [\r\n        'WWWWWWWWWWWWWWW',\r\n        'W             W',\r\n        'W X XXX XXX X W',\r\n        'W             W',\r\n        'W X X X X X X W',\r\n        'W X         X W',\r\n        'W X X X X X X W',\r\n        'W             W',\r\n        'W XXX X X XXX W',\r\n        'W             W',\r\n        'WWWWWWWWWWWWWWW'\r\n    ]\r\n]\r\n\r\n// define all board elements\r\n// type: defines what kind of material it is:\r\n// empty - you can walk on it\r\n// soft - you can destroy it\r\n// solid - undestructible\r\nBoard.elements = {\r\n    'floor': {sx: 174, sy: 16, type: 'empty'},\r\n    'W': {sx: 190, sy: 16, type: 'solid'}, // outer wall\r\n    'X': {sx: 206, sy: 16, type: 'solid'}, // inner wall\r\n    'box': {sx: 126, sy: 0, type: 'soft'},\r\n}\r\nexport function Board(){\r\n    this.frameWidth = 16;\r\n    this.frameHeight = 16;\r\n    this.parse(Board.templates[ VAR.random(0, Board.templates.length - 1) ]); // pick rundom board from our templates and convert it into right format\r\n    // add boxes on the board\r\n    for( let i = 0 ; i < 20 ; i++){\r\n        this.addCrate();\r\n    }\r\n}\r\n\r\nBoard.prototype.parse = function(arr){ // convert string board to array of arrays with objects inside\r\n    this.emptySpaces = []; // array to store all exisiting empty places (grass) on board\r\n    this.b = [];\r\n    \r\n    for (let i = 0 ; i <  arr.length ; i++){ // iterate through each raw of the board\r\n        this.b.push([]); // create array for each row of the board\r\n        for (let j = 0 ; j < arr[i].length ; j++){ // iterate through each element (letter) in each row\r\n            // push corresponding object definition in place of a specific letter key\r\n            this.b[i].push( Board.elements[arr[i].charAt(j) == ' ' ? 'floor' : arr[i].charAt(j)] ); // pick appropriate obj definition from Board.elements\r\n            \r\n            if (this.b[i][j].type === 'empty' && !(i==1 && j == 1) && !(i==2 && j==1) && !(i==1 && j==2)){\r\n                this.emptySpaces.push({ x:j, y:i }); \r\n            }\r\n        }\r\n    }\r\n    this.emptySpaces = VAR.shuffle(this.emptySpaces); // shuffle array storing empty spaces\r\n};\r\n\r\nBoard.prototype.getEmptySpace = function () { \r\n    return this.emptySpaces.length > 0 ? this.emptySpaces.shift() : null;\r\n};\r\n\r\nBoard.prototype.addCrate = function () { // adding crate\r\n    let position = this.getEmptySpace();\r\n    if(position){\r\n        this.b[position.y][position.x] = Board.elements.box;\r\n    }\r\n};\r\n\r\nBoard.prototype.draw = function(){\r\nfor (let i = 0 ; i < this.b.length; i++){ // iterate through each row\r\n\r\nfor (let j = 0 ; j < this.b[i].length ; j++){ // iterate through each element in each row\r\n    Game.ctx.drawImage( // draw method\r\n        Game.sprite, // image source\r\n        this.b[i][j].sx, // coords\r\n        this.b[i][j].sy,\r\n        this.frameWidth, // size\r\n        this.frameHeight,\r\n        j * this.frameWidth * VAR.scale, // where to put it on canvas\r\n        i * this.frameHeight * VAR.scale,\r\n        this.frameWidth * VAR.scale, // how big is the drawn image\r\n        this.frameHeight * VAR.scale\r\n    )   \r\n     if(this.b[i][j].type == 'bomb'){ // drawing bombs\r\n         this.b[i][j].draw();\r\n     }\r\n\r\n    }\r\n\r\n}\r\n}","import {Game} from './index.mjs';\r\nimport {Board} from './Board.mjs';\r\nimport {VAR} from './VAR.mjs';\r\n\r\nBomb.count = 0;\r\nBomb.maxCount = 2;\r\nexport function Bomb(column, row){\r\n    if(Bomb.count < Bomb.maxCount && Game.board.b[row][column].type != 'bomb'){\r\n        Bomb.count++;\r\n        this.type = 'bomb';\r\n        this.sx = Board.elements.floor.sx;\r\n        this.sy = Board.elements.floor.sy;\r\n        this.bombSx = 126; // sprite position\r\n        this.bombSy = 16; // sprite position\r\n        this.frames = [0,0,1,1,2,2]\r\n        this.currentFrame = 0;\r\n        this.column = column;\r\n        this.row = row;\r\n\r\n        Game.board.b[this.row][this.column] = this; // changing game greenfield from empty to bomb\r\n    }\r\n}\r\n\r\nBomb.prototype.draw = function(){\r\n    Game.ctx.drawImage(\r\n        Game.sprite,\r\n        this.bombSx+this.frames[this.currentFrame]*Game.board.frameWidth, // dynamic definition to assign next frames\r\n        this.bombSy,\r\n        Game.board.frameWidth,\r\n        Game.board.frameHeight,\r\n        this.column*Game.board.frameWidth*VAR.scale,\r\n        this.row*Game.board.frameHeight*VAR.scale,\r\n        Game.board.frameWidth*VAR.scale,\r\n        Game.board.frameHeight*VAR.scale\r\n    );\r\n    this.currentFrame = this.currentFrame+1 < this.frames.length ? this.currentFrame+1 : 0;\r\n}","import {Game} from './index.mjs';\r\nimport {VAR} from './VAR.mjs';\r\n\r\nCharacter.count = 0;\r\n\r\nexport function Character(inheritance){\r\n    Character.count++; // controlling how many characters have been generated\r\n    this.id = `char_${Character.count}`; // setting specific id to each character\r\n    \r\n    if (!inheritance){ // allowed only if given argument is true\r\n        Game.toDraw[this.id] = this; // pushing created character into object stroing all characters\r\n    }\r\n    \r\n    this.frameWidth = 21; // width of a sprite\r\n    this.frameHeight = 24; // height of a sprite\r\n\r\n    this.modX = -2;\r\n    this.modY = -8;\r\n\r\n    this.speed = 2;\r\n\r\n    this.currentFrame = 0; // current frame of animation\r\n\r\n    this.maxFrameDelay = 2; // properties to slow down animation\r\n    this.currentFrameDelay = 0;\r\n}\r\n\r\nCharacter.prototype.draw = function (){ // draw method prototype\r\n    if(this.state.slice(-2) == 'go'){    \r\n        // char speed depending on his state\r\n        if (this.state == 'down_go'){\r\n            this.y += this.speed;\r\n        }else if (this.state == 'right_go'){\r\n            this.x += this.speed;\r\n        }else if (this.state == 'up_go'){\r\n            this.y -= this.speed;\r\n        }else if (this.state == 'left_go'){\r\n            this.x -= this.speed;\r\n        }\r\n        \r\n        this.rowAndColumn();\r\n        \r\n    } \r\n\r\n    // Game.ctx.fillRect(\r\n    //     this.column*Game.board.frameWidth*VAR.scale,\r\n    //     this.row*Game.board.frameHeight*VAR.scale,\r\n    //     Game.board.frameWidth*VAR.scale,\r\n    //     Game.board.frameHeight*VAR.scale\r\n    //     );\r\n\r\n    //     Game.ctx.fillRect(\r\n    //         this.nextColumn*Game.board.frameWidth*VAR.scale,\r\n    //         this.nextRow*Game.board.frameHeight*VAR.scale,\r\n    //         Game.board.frameWidth*VAR.scale,\r\n    //         Game.board.frameHeight*VAR.scale\r\n    //         );\r\n\r\n    if(this.states[this.state].flip){ // inverse image if 'flip' property is true\r\n    Game.ctx.save(); // saving a given canvas state\r\n    Game.ctx.scale(-1,1); // inversing canvas\r\n    }\r\n\r\n    Game.ctx.drawImage( // definig what part of image should be clipped\r\n        Game.sprite,\r\n        this.states[this.state].sx + this.states[this.state].f[this.currentFrame]*this.frameWidth,\r\n        this.states[this.state].sy,\r\n        this.frameWidth,\r\n        this.frameHeight,\r\n        this.states[this.state].flip ? (-this.frameWidth - this.modX - this.x )*VAR.scale : (this.x + this.modX)*VAR.scale,\r\n        (this.y+this.modY)*VAR.scale,\r\n        this.frameWidth*VAR.scale,\r\n        this.frameHeight*VAR.scale\r\n    );\r\n    if(this.states[this.state].flip){\r\n        Game.ctx.restore(); // restoring previously saved canvas state\r\n      \r\n    };\r\n    if (this.currentFrameDelay < this.maxFrameDelay){ // slowing down animation\r\n        this.currentFrameDelay++;\r\n    } else {\r\n        this.currentFrameDelay = 0;\r\n        this.currentFrame = this.currentFrame+1 >= this.states[this.state].f.length ? 0 : this.currentFrame+1;\r\n    }\r\n}\r\n\r\n// adding collision detection for Character\r\nCharacter.prototype.rowAndColumn = function() {\r\n    // compute in which row and in which column character is located\r\n    this.row = Math.round(this.y/Game.board.frameHeight);\r\n    this.column = Math.round(this.x/Game.board.frameWidth);\r\n    if(this.state.slice(-3) == '_go'){ // determine on which board element char is\r\n        if (this.state == 'left_go' || this.state == 'right_go'){\r\n            this.nextRow = this.row;\r\n            this.nextColumn = this.state == 'left_go' ? Math.floor(this.x/Game.board.frameWidth) : Math.ceil(this.x/Game.board.frameWidth); // round down if movement to left and round up when char moving right\r\n        } else {\r\n            this.nextColumn = this.column;\r\n            this.nextRow = this.state == 'up_go' ? Math.floor(this.y/Game.board.frameHeight) : Math.ceil(this.y/Game.board.frameHeight);\r\n        };\r\n        // check if current column and row changes or not && check if next place is empty or not\r\n        if( !(this.row == this.nextRow && this.column == this.nextColumn) && Game.board.b[this.nextRow][this.nextColumn].type != 'empty' ){\r\n\r\n            this.state = this.state.slice(0,-3);\r\n            this.currentFrame = 0;\r\n            // when char hits an obstacle we want to put him on the center of the area\r\n            if (this.row!=this.nextRow){\r\n                this.y = this.row*Game.board.frameHeight;\r\n            } else {\r\n                this.x = this.column*Game.board.frameWidth;\r\n            }\r\n        } else { // situation when character can walk on certain area - let's center him!\r\n            if (this.row!=this.nextRow){ // both ifs are making sure that character is walking in the 'tunnel'\r\n                this.x = this.nextColumn*Game.board.frameWidth;\r\n            } else if (this.column!=this.nextColumn){\r\n                this.y = this.nextRow*Game.board.frameHeight;\r\n            }\r\n        }\r\n    } else { // if char not moving then don't reasign row and col position\r\n        this.nextRow = this.row;\r\n        this.nextColumn = this.column;\r\n    }\r\n}\r\n\r\nexport function Hero(){ // deifing main hero\r\n    Character.call(this); // extending Character class\r\n    this.state = 'down'; // current animation state of Hero\r\n    this.states = { // definig all possible animation states of Hero\r\n        'down': {sx:0, sy:0, f:[0]},\r\n        'down_go': {sx:0, sy:0, f:[1,0,2,0]},\r\n        'left': {sx:63, sy:0, f:[0]},\r\n        'left_go': {sx:63, sy:0, f:[1,0,2,0]},\r\n        'up': {sx:0, sy:24, f:[0]},\r\n        'up_go': {sx:0, sy:24, f:[1,0,2,0]},\r\n        'right': {sx:63, sy:0, f:[0], flip: true}, // flip set up to inverse character graphics\r\n        'right_go': {sx:63, sy:0, f:[1,0,2,0], flip: true},\r\n        'ko': {sx: 0, sy: 48, f:[0,1,0,1,0,1,2,3,4]} // death animation\r\n    };\r\n    this.x = Game.board.frameWidth;\r\n    this.y = Game.board.frameHeight;\r\n\r\n    this.rowAndColumn();\r\n}\r\n\r\nHero.prototype = new Character(true); // extending Character draw method to Hero constructor\r\nHero.prototype.constructor = Hero;\r\n\r\nHero.prototype.updateState = function(){\r\n    this.tempState = this.state; // temporary state variable\r\n    if (Game.key_37){ // when arrow left is pressed then change temporary state to left_go\r\n        this.tempState = 'left_go';\r\n    } else if (Game.key_38){ // when arrow left is pressed then change temporary state to left_go\r\n        this.tempState = 'up_go';\r\n    }else if (Game.key_39){ // when arrow left is pressed then change temporary state to left_go\r\n        this.tempState = 'right_go';\r\n    }else if (Game.key_40){ // when arrow left is pressed then change temporary state to left_go\r\n        this.tempState = 'down_go';\r\n    }else if (this.state.slice(-2) == 'go'){ // check if current active state was with 'go' ending\r\n    this.tempState = this.state.slice(0,this.state.indexOf('_go')); // slice last 3 digits to be left with static state\r\n    }\r\n    if (this.tempState!= this.state){ // check if state has changed\r\n        this.currentFrame = 0;\r\n        this.state = this.tempState; // reasign state to temporary state\r\n    }\r\n}\r\n\r\nEnemy.all = {};\r\nexport function Enemy(x,y){\r\n    Character.call(this);\r\n    Enemy.all[this.id] = this; // assign id to enemy\r\n    this.state = 'down'; // current animation state of Enemy\r\n    this.states = { // definig all possible animation states of Enemy\r\n        'down': {sx:0, sy:72, f:[0]}, // static\r\n        'down_go': {sx:0, sy:72, f:[1,0,2,0]}, // dynamic\r\n        'left': {sx:63, sy:24, f:[0]},\r\n        'left_go': {sx:63, sy:24, f:[1,0,2,0]},\r\n        'up': {sx:63, sy:72, f:[0]},\r\n        'up_go': {sx:63, sy:72, f:[1,0,2,0]},\r\n        'right': {sx:63, sy:24, f:[0], flip: true}, // flip set up to inverse character graphics\r\n        'right_go': {sx:63, sy:24, f:[1,0,2,0], flip: true},\r\n        'ko': {sx: 0, sy: 96, f:[0,1,2,3,4,5]} // death animation\r\n    };\r\n    this.x = x;\r\n    this.y = y;\r\n    \r\n    this.rowAndColumn();\r\n    this.setDirection();\r\n}\r\n\r\nEnemy.prototype = new Character(true); // extending Character draw method to Hero constructor\r\nEnemy.prototype.constructor = Enemy;\r\n\r\nEnemy.prototype.parent = Character.prototype; // used to extend method assigned to Character\r\n\r\nEnemy.prototype.setDirection = function(){\r\n    this.canGo = this.canGo || []; // assign array for possible directions or use the one already assigned\r\n    this.canGo.length = 0; // empty the array\r\n    // enemy already has assigned position\r\n    // we have to iterate through all positions around it and check if they are empty of solid\r\n    \r\n    for (let i = this.column-1; i<= this.column+1; i++){\r\n\r\n            for (let j = this.row-1 ; j <= this.row+1; j++){\r\n\r\n                if ( !(i==this.column && j==this.row)){ // don't check position where enemy is alrady situated\r\n                    \r\n                    if ( i == this.column || j == this.row ) {// don't check corners\r\n                        if(Game.board.b[j][i].type == 'empty'){\r\n                            this.canGo.push({x:i, y:j});\r\n                        } \r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n    if(this.canGo.length>0){\r\n            this.tempPos = this.canGo[VAR.random(0, this.canGo.length-1)];\r\n            \r\n            if(this.column < this.tempPos.x){\r\n                this.state = 'right_go';\r\n            } else if (this.column> this.tempPos.x){\r\n                this.state = 'left_go';\r\n            } else if (this.row < this.tempPos.y){\r\n                this.state = 'down_go';\r\n            }else if (this.row > this.tempPos.y){\r\n                this.state = 'up_go';\r\n            }\r\n    } else if (this.state.slice(-2) == 'go'){\r\n         this.state = this.state.slice(0, -3);\r\n    }\r\n}\r\n\r\nEnemy.prototype.rowAndColumn = function(){ // extending rowAndColumn method\r\n    this.previousState = this.state // saving current state to this.previousState\r\n    this.parent.rowAndColumn.call(this); // assigning this to parent\r\n\r\n    if (this.previousState != this.state && this.state.slice(-2) != 'go' && this.previousState.slice(-2) == 'go'){\r\n        this.setDirection();\r\n    }\r\n}","// variable used to store handy properties used among the way\r\nexport const VAR = { \r\n    fps: 15, // frames per second for animation\r\n    H: 0, // window height\r\n    W: 0, // window width\r\n    scale: 4, // game elements will be loaded in proper scale\r\n    lastTime: 0, // property for rAF\r\n    random: (min, max)=>{ // ranodm number generator\r\n        return Math.floor(Math.random()* (max-min+1) )+ min;\r\n    },\r\n    shuffle: function (arr) { // method to shuffle array of emty spaces\r\n        let counter = arr.length;\r\n        let temp;\r\n        let index;\r\n        while(counter > 0){\r\n            counter--;\r\n            index = Math.floor(Math.random()*counter);\r\n            temp = arr[counter];\r\n            arr[counter] = arr[index];\r\n            arr[index] = temp;\r\n        }\r\n        return arr;\r\n    }\r\n}","import {Character, Hero, Enemy} from './Characters.mjs';\r\nimport {VAR} from './VAR.mjs';\r\nimport {Board} from './Board.mjs';\r\nimport { Bomb } from './Bomb.mjs';\r\n\r\ndocument.addEventListener('DOMContentLoaded', function (){ \r\n    Game.sprite = new Image();\r\n    Game.sprite.onload = Game.init; // makes sure that init() is launched after image is loaded\r\n    Game.sprite.src = 'dist/img/bombe.png';\r\n});\r\n\r\n// object containg basic game properties\r\nexport let Game = {\r\n    init: function() {\r\n        Game.canvas = document.createElement('canvas'); // create canvas\r\n        Game.ctx = Game.canvas.getContext('2d'); // get canvas 2d context\r\n        Game.board = new Board();\r\n        Game.layout(); // launch function to resize W and H based on window inner dimensions\r\n        window.addEventListener('resize', Game.layout); // launch layout() function on window resize\r\n        document.body.appendChild(Game.canvas); // append canvas to DOM\r\n    \r\n        Game.toDraw = {}; // object to store all characters   \r\n\r\n        Game.hero = new Hero();\r\n\r\n        let tempEmpty;\r\n        // create 5 enemies in random places\r\n        for (let i = 0 ; i < 5 ; i++){\r\n            \r\n            tempEmpty = Game.board.getEmptySpace();\r\n            new Enemy(tempEmpty.x*Game.board.frameWidth, tempEmpty.y*Game.board.frameHeight);\r\n\r\n        }\r\n\r\n        // add event listeners for char sterring\r\n        \r\n        window.addEventListener('keydown', Game.onKey);\r\n        window.addEventListener('keyup', Game.onKey);\r\n\r\n        \r\n\r\n        Game.animationLoop(); // launch game animation loop\r\n        },\r\n\r\n    onKey: (e)=>{\r\n        if (e.keyCode >= 37 && e.keyCode<= 40 || e.keyCode == 32){ // use only arrows and space in game\r\n            e.preventDefault(); // turn off standard key actions\r\n            if(e.type == 'keydown' && !Game[`key_${e.keyCode}`]){ // when key has been pressed\r\n                Game[`key_${e.keyCode}`] = true; // set key to work\r\n                if(e.keyCode >= 37 && e.keyCode <= 40 ){ // if any arrow was pressed then make sure to disable previously pressed arrow\r\n                    for (let i = 37; i <= 40 ; i++){\r\n                        if(i!= e.keyCode){\r\n                            Game[`key_${i}`] = false;\r\n                        }\r\n                    }\r\n                    Game.hero.updateState();\r\n                }else{\r\n                    new Bomb(Game.hero.column, Game.hero.row);\r\n                }\r\n                Game.hero.updateState(); // launch update function when key is pressed (conditions above)\r\n            } else if (e.type == 'keyup'){ // update state when key is released as well (char is standing)\r\n                Game[`key_${e.keyCode}`] = false;\r\n                Game.hero.updateState();\r\n            }\r\n        }\r\n    },\r\n\r\n    layout: ()=> {\r\n        VAR.H = window.innerHeight; // get window dimensions dynamically\r\n        VAR.W = window.innerWidth; // as above\r\n        \r\n        VAR.scale = Math.max(1, Math.min( \r\n            Math.floor(VAR.H/(Game.board.frameWidth*Game.board.b[0].length)),\r\n            Math.floor(VAR.W/(Game.board.frameHeight*Game.board.b.length))\r\n            ));\r\n                \r\n        Game.canvas.width = Math.round(VAR.scale*Game.board.frameWidth*Game.board.b[0].length); // as above\r\n        Game.canvas.height = Math.round(VAR.scale*Game.board.frameHeight*Game.board.b.length); // set canvas dimensions based on window dimensions\r\n        \r\n        Game.canvas.style[Modernizr.prefixed('transform')] = `translate(${Math.round( (VAR.W-Game.canvas.width)/2 )}px, ${Math.round( (VAR.H-Game.canvas.height)/2 ) }px)`;\r\n        \r\n//'translate('+Math.round((VAR.W-Game.canvas.width)/2) + 'px,' +Math.round((VAR.H-Game.canvas.height)/2)+'px)';\r\n        Game.ctx.imageSmoothingEnabled = false; // character pixels are super sharp\r\n        Game.ctx.mozImageSmoothingEnabled = false;\r\n        Game.ctx.oImageSmoothingEnabled = false;\r\n        Game.ctx.webkitImageSmoothingEnabled = false;\r\n    },\r\n\r\n    animationLoop: (time)=> {\r\n        requestAnimationFrame(Game.animationLoop);\r\n        // limit fps to desired rate\r\n            if(time-VAR.lastTime >= 1000/VAR.fps){\r\n                VAR.lastTime = time;\r\n\r\n                Game.ctx.clearRect(0,0,VAR.W, VAR.H);\r\n                \r\n                Game.board.draw();\r\n                \r\n                for(let i in Game.toDraw){        \r\n                        Game.toDraw[i].draw();\r\n                }\r\n            }\r\n        }\r\n}"],"sourceRoot":""}