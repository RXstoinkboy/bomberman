{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/js/Board.mjs","webpack:///./src/js/Bomb.mjs","webpack:///./src/js/Characters.mjs","webpack:///./src/js/Crate.mjs","webpack:///./src/js/VAR.mjs","webpack:///./src/js/index.mjs"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAEkB;AAGE;AACa;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,6BAA6B,4CAAG;AAChC;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA,wCAAwC;AACxC;AACA;;AAEA,iBAAiB,gBAAgB,OAAO;AACxC;AACA,mBAAmB,mBAAmB,OAAO;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,qBAAqB,4CAAG;AACxB;;AAEA;AACA;AACA;;AAEA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,mBAAmB,OAAO;AAC3C,mBAAmB,sBAAsB,OAAO;AAChD,MAAM,+CAAI;AACV,QAAQ,+CAAI;AACZ;AACA;AACA;AACA;AACA,8BAA8B,4CAAG;AACjC,+BAA+B,4CAAG;AAClC,0BAA0B,4CAAG;AAC7B,2BAA2B,4CAAG;AAC9B;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEoB;AAGA;AAGF;AACiB;;AAEnC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,qCAAqC,+CAAI,sEAAsE,+CAAI,6CAA6C,+CAAI;AACpK;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gDAAK;AACnB,cAAc,gDAAK;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,IAAI,+CAAI;AACR;AACA;;AAEA;AACA;AACA,iCAAiC,+CAAI,oBAAoB,4CAAG;AAC5D,8BAA8B,+CAAI,qBAAqB,4CAAG;;AAE1D;AACA,MAAM,+CAAI;AACV;AACA,QAAQ,+CAAI;AACZ,4CAA4C,+CAAI,qBAAqB,4CAAG;AACxE,OAAO;AACP,QAAQ,+CAAI;AACZ,4CAA4C,+CAAI,oBAAoB,4CAAG;AACvE;AACA;;AAEA,IAAI,+CAAI;AACR,MAAM,+CAAI;AACV,2DAA2D,+CAAI;AAC/D;AACA,MAAM,+CAAI;AACV,MAAM,+CAAI;AACV;AACA;AACA,MAAM,+CAAI,oBAAoB,4CAAG;AACjC,MAAM,+CAAI,qBAAqB,4CAAG;AAClC;AACA;AACA,MAAM,+CAAI;AACV;AACA;AACA;AACA,GAAG,iCAAiC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO,OAAO;AACjC;AACA;;AAEA;AACA;;AAEA,mDAAmD;AACnD;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA,qBAAqB,gBAAgB;AACrC;AACA,YAAY,+CAAI;AAChB,cAAc,+CAAI;AAClB,gBAAgB,gDAAK;AACrB;AACA,WAAW;AACX;AACA,WAAW;AACX,SAAS,UAAU,+CAAI,8DAA8D,+CAAI,mDAAmD;AAC5I,UAAU,+CAAI;AACd,SAAS;AACT;AACA;AACA;AACA;AACA,GAAG,OAAO;AACV,IAAI,+CAAI,kCAAkC,gDAAK;AAC/C;AACA;;;;;;;;;;;;;ACxKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEoB;AAGF;;AAElB;;AAEO;AACP;AACA,oBAAoB,gBAAgB;;AAEpC,qBAAqB;AACrB,IAAI,+CAAI;AACR;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM,+CAAI,qDAAqD,+CAAI;AACnE;AACA;;AAEA,qCAAqC;AACrC,IAAI,+CAAI;AACR,IAAI,+CAAI;AACR;;AAEA,EAAE,+CAAI;AACN,IAAI,+CAAI;AACR;AACA;AACA;AACA;AACA,6EAA6E,4CAAG,gCAAgC,4CAAG;AACnH,2BAA2B,4CAAG;AAC9B,sBAAsB,4CAAG;AACzB,uBAAuB,4CAAG;AAC1B;AACA;AACA,IAAI,+CAAI;AACR;AACA,oDAAoD;AACpD;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,+CAAI;AACrC,oCAAoC,+CAAI;AACxC,sCAAsC;AACtC;AACA;AACA,sEAAsE,+CAAI,wCAAwC,+CAAI;AACtH,KAAK;AACL;AACA,iEAAiE,+CAAI,yCAAyC,+CAAI;AAClH;AACA;AACA,yEAAyE,+CAAI;AAC7E;AACA;AACA;AACA;AACA,4BAA4B,+CAAI;AAChC,OAAO;AACP,+BAA+B,+CAAI;AACnC;AACA,KAAK,OAAO;AACZ,qCAAqC;AACrC,mCAAmC,+CAAI;AACvC,OAAO;AACP,gCAAgC,+CAAI;AACpC;AACA;AACA,GAAG,OAAO;AACV;AACA;AACA;AACA;;AAEA,yCAAyC;AACzC;AACA;;AAEA,2CAA2C;AAC3C,SAAS,+CAAI;AACb;;AAEO,kBAAkB;AACzB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,WAAW,+CAAI;AACf,WAAW,+CAAI;;AAEf;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM,+CAAI,UAAU;AACpB;AACA,GAAG,UAAU,+CAAI,UAAU;AAC3B;AACA,GAAG,UAAU,+CAAI,UAAU;AAC3B;AACA,GAAG,UAAU,+CAAI,UAAU;AAC3B;AACA,GAAG,yCAAyC;AAC5C;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE,+CAAI;AACN;;AAEA;AACA,OAAO,+CAAI;AACX,IAAI,+CAAI;AACR;AACA;AACA;;AAEA,2CAA2C;AAC3C;AACA;AACA,oCAAoC,+CAAI,6CAA6C,+CAAI,wDAAwD,+CAAI,8CAA8C,+CAAI;AACvM;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACO;AACP;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,sBAAsB;AACrD,8BAA8B,mBAAmB;AACjD,iDAAiD;AACjD,gDAAgD;AAChD,cAAc,+CAAI;AAClB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,4CAAG;;AAEjC;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA,4CAA4C;AAC5C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvXA;AAAA;AAAA;AAAA;AAAA;AAEoB;AAGF;AAGE;;AAEb,8BAA8B;AACrC,YAAY,gDAAK;AACjB,YAAY,gDAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAE,+CAAI;AACN;;AAEA;AACA,EAAE,+CAAI;AACN,IAAI,+CAAI;AACR,mDAAmD,+CAAI;AACvD;AACA,IAAI,+CAAI;AACR,IAAI,+CAAI;AACR,kBAAkB,+CAAI,oBAAoB,4CAAG;AAC7C,eAAe,+CAAI,qBAAqB,4CAAG;AAC3C,IAAI,+CAAI,oBAAoB,4CAAG;AAC/B,IAAI,+CAAI,oBAAoB,4CAAG;AAC/B;AACA;AACA;AACA,IAAI,+CAAI,kCAAkC,gDAAK;AAC/C;AACA;;;;;;;;;;;;;ACzCA;AAAA;AAAA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,CAAC;AACD,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIyB;AAGP;AAGE;AAGD;;AAEnB;AACA;AACA;AACA;AACA,CAAC;;AAED;AACO;AACP;AACA;AACA;AACA,qBAAqB,gDAAK;AAC1B;AACA;AACA;;AAEA,oBAAoB;;AAEpB,oBAAoB,oDAAI;;AAExB;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,UAAU,qDAAK;AACf;;AAEA;;AAEA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA,gEAAgE;AAChE;AACA,8CAA8C,UAAU,KAAK;AAC7D,oBAAoB,UAAU;AAC9B,iDAAiD;AACjD,0BAA0B,SAAS;AACnC;AACA,0BAA0B,EAAE;AAC5B;AACA;AACA;AACA,SAAS;AACT,cAAc,8CAAI;AAClB;AACA;AACA,OAAO,8BAA8B;AACrC,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA,GAAG;;AAEH;AACA,IAAI,4CAAG;AACP,IAAI,4CAAG;;AAEP,IAAI,4CAAG;AACP,iBAAiB,4CAAG;AACpB,iBAAiB,4CAAG;AACpB;;AAEA,mCAAmC,4CAAG;AACtC,oCAAoC,4CAAG;;AAEvC,sEAAsE,YAAY,4CAAG,6BAA6B,MAAM,YAAY,4CAAG,8BAA8B;;AAErK;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,eAAe,4CAAG,oBAAoB,4CAAG;AACzC,MAAM,4CAAG;;AAET,+BAA+B,4CAAG,IAAI,4CAAG;;AAEzC;;AAEA;AACA;AACA;AACA;AACA;AACA","file":"bundle-index.mjs","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/js/index.mjs\");\n","import {\r\n  VAR\r\n} from './VAR.mjs'\r\nimport {\r\n  Game\r\n} from './index.mjs'\r\nimport { Bomb } from './Bomb.mjs'\r\n\r\nBoard.templates = [ // creating board templates here\r\n  [\r\n    'WWWWWWWWWWWWWWW',\r\n    'W             W',\r\n    'W X X X X X X W',\r\n    'W             W',\r\n    'W X X X X X X W',\r\n    'W             W',\r\n    'W X X X X X X W',\r\n    'W             W',\r\n    'W X X X X X X W',\r\n    'W             W',\r\n    'WWWWWWWWWWWWWWW'\r\n  ],\r\n  [\r\n    'WWWWWWWWWWWWWWW',\r\n    'W             W',\r\n    'W X XXX XXX X W',\r\n    'W             W',\r\n    'W X X X X X X W',\r\n    'W X         X W',\r\n    'W X X X X X X W',\r\n    'W             W',\r\n    'W XXX X X XXX W',\r\n    'W             W',\r\n    'WWWWWWWWWWWWWWW'\r\n  ]\r\n]\r\n\r\n// define all board elements\r\n// type: defines what kind of material it is:\r\n// empty - you can walk on it\r\n// soft - you can destroy it\r\n// solid - undestructible\r\nBoard.elements = {\r\n  floor: {\r\n    sx: 174,\r\n    sy: 16,\r\n    type: 'empty',\r\n    subtype: 'board'\r\n  },\r\n  W: {\r\n    sx: 190,\r\n    sy: 16,\r\n    type: 'solid',\r\n    subtype: 'board'\r\n  }, // outer wall\r\n  X: {\r\n    sx: 206,\r\n    sy: 16,\r\n    type: 'solid',\r\n    subtype: 'board'\r\n  }, // inner wall\r\n  box: {\r\n    sx: 126,\r\n    sy: 0,\r\n    type: 'soft',\r\n    subtype: 'board',\r\n    koObj: 'Crate'\r\n  }\r\n}\r\nexport function Board () {\r\n  this.frameWidth = 16\r\n  this.frameHeight = 16\r\n  this.parse(Board.templates[VAR.random(0, Board.templates.length - 1)]) // pick rundom board from our templates and convert it into right format\r\n  // add boxes on the board\r\n  for (let i = 0; i < 20; i++) {\r\n    this.addCrate()\r\n  }\r\n}\r\n\r\nBoard.prototype.parse = function (arr) { // convert string board to array of arrays with objects inside\r\n  this.emptySpaces = [] // array to store all exisiting empty places (grass) on board\r\n  this.b = []\r\n\r\n  for (let i = 0; i < arr.length; i++) { // iterate through each raw of the board\r\n    this.b.push([]) // create array for each row of the board\r\n    for (let j = 0; j < arr[i].length; j++) { // iterate through each element (letter) in each row\r\n      // push corresponding object definition in place of a specific letter key\r\n      this.b[i].push(Board.elements[arr[i].charAt(j) == ' ' ? 'floor' : arr[i].charAt(j)]) // pick appropriate obj definition from Board.elements\r\n\r\n      if (this.b[i][j].type === 'empty' && !(i == 1 && j == 1) && !(i == 2 && j == 1) && !(i == 1 && j == 2)) {\r\n        this.emptySpaces.push({\r\n          x: j,\r\n          y: i\r\n        })\r\n      }\r\n    }\r\n  }\r\n  this.emptySpaces = VAR.shuffle(this.emptySpaces) // shuffle array storing empty spaces\r\n}\r\n\r\nBoard.prototype.getEmptySpace = function () {\r\n  return this.emptySpaces.length > 0 ? this.emptySpaces.shift() : null\r\n}\r\n\r\nBoard.prototype.addCrate = function () { // adding crate\r\n  const position = this.getEmptySpace()\r\n  if (position) {\r\n    this.b[position.y][position.x] = Board.elements.box\r\n  }\r\n}\r\n\r\nBoard.prototype.draw = function () {\r\n  for (let i = 0; i < this.b.length; i++) { // iterate through each row\r\n    for (let j = 0; j < this.b[i].length; j++) { // iterate through each element in each row\r\n      Game.ctx.drawImage( // draw method\r\n        Game.sprite, // image source\r\n        this.b[i][j].sx, // coords\r\n        this.b[i][j].sy,\r\n        this.frameWidth, // size\r\n        this.frameHeight,\r\n        j * this.frameWidth * VAR.scale, // where to put it on canvas\r\n        i * this.frameHeight * VAR.scale,\r\n        this.frameWidth * VAR.scale, // how big is the drawn image\r\n        this.frameHeight * VAR.scale\r\n      )\r\n      if (this.b[i][j].subtype != 'board') { // drawing bombs\r\n        this.b[i][j].draw()\r\n      }\r\n    }\r\n  }\r\n}\r\n","import {\r\n  Game\r\n} from './index.mjs'\r\nimport {\r\n  Board\r\n} from './Board.mjs'\r\nimport {\r\n  VAR\r\n} from './VAR.mjs'\r\nimport { Crate } from './Crate.mjs'\r\n\r\nBomb.count = 0\r\nBomb.maxCount = 2\r\nBomb.elements = { // bomb states: before and after explosions\r\n  bomb: {\r\n    sx: 126,\r\n    sy: 16,\r\n    frames: [0, 0, 1, 1, 2, 2]\r\n  },\r\n  center: {\r\n    sx: 126,\r\n    sy: 64,\r\n    frames: [0, 0, 1, 1, 2, 2, 3, 3, 2, 2, 1, 1, 0, 0]\r\n  }, // explode and disapear\r\n  up_boom: {\r\n    sx: 126,\r\n    sy: 96,\r\n    frames: [0, 0, 1, 1, 2, 2, 3, 3, 2, 2, 1, 1, 0, 0]\r\n  },\r\n  down_boom: {\r\n    sx: 126,\r\n    sy: 96,\r\n    frames: [0, 0, 1, 1, 2, 2, 3, 3, 2, 2, 1, 1, 0, 0]\r\n  },\r\n  right_boom: {\r\n    sx: 126,\r\n    sy: 48,\r\n    frames: [0, 0, 1, 1, 2, 2, 3, 3, 2, 2, 1, 1, 0, 0]\r\n  },\r\n  left_boom: {\r\n    sx: 126,\r\n    sy: 48,\r\n    frames: [0, 0, 1, 1, 2, 2, 3, 3, 2, 2, 1, 1, 0, 0]\r\n  },\r\n  up_boom_end: {\r\n    sx: 126,\r\n    sy: 80,\r\n    frames: [0, 0, 1, 1, 2, 2, 3, 3, 2, 2, 1, 1, 0, 0]\r\n  },\r\n  down_boom_end: {\r\n    sx: 126,\r\n    sy: 80,\r\n    frames: [0, 0, 1, 1, 2, 2, 3, 3, 2, 2, 1, 1, 0, 0],\r\n    flip: true\r\n  },\r\n  left_boom_end: {\r\n    sx: 126,\r\n    sy: 32,\r\n    frames: [0, 0, 1, 1, 2, 2, 3, 3, 2, 2, 1, 1, 0, 0]\r\n  },\r\n  right_boom_end: {\r\n    sx: 126,\r\n    sy: 32,\r\n    frames: [0, 0, 1, 1, 2, 2, 3, 3, 2, 2, 1, 1, 0, 0],\r\n    flip: true\r\n  }\r\n}\r\n\r\nexport function Bomb (column, row, boomType) {\r\n  if ((Bomb.count < Bomb.maxCount && Game.board.b[row][column].subtype != 'bomb' && !boomType) || (boomType && Game.board.b[row][column].subtype == 'board' && !Game.board.b[row][column].bumType)) {\r\n    if (!boomType) {\r\n      Bomb.count++\r\n    }\r\n    this.boomType = boomType\r\n    this.type = boomType ? 'empty' : 'solid' // make sure that you can't walk over a bomb before it explodes\r\n    this.subtype = 'bomb'\r\n    this.data = !boomType ? Bomb.elements.bomb : Bomb.elements[boomType]\r\n    this.sx = Board.elements.floor.sx\r\n    this.sy = Board.elements.floor.sy\r\n    this.bombSx = 126 // sprite position\r\n    this.bombSy = 16 // sprite position\r\n    this.frames = [0, 0, 1, 1, 2, 2]\r\n    this.currentFrame = 0\r\n    this.column = column\r\n    this.row = row\r\n\r\n    this.timer = boomType ? this.data.frames.length : 30 // bomb should explode after 30 frames\r\n    this.range = 2 // 2 blocks range of explosion\r\n\r\n    Game.board.b[row][column] = this // changing game greenfield from empty to bomb\r\n  }\r\n}\r\n\r\nBomb.prototype.draw = function () {\r\n  if (this.timer > 0) {\r\n    this.targetX = this.column * Game.board.frameWidth * VAR.scale\r\n    this.targetY = this.row * Game.board.frameHeight * VAR.scale\r\n\r\n    if (this.data.flip) {\r\n      Game.ctx.save() // save all vanvas settings\r\n      if (this.boomType == 'down_boom_end') {\r\n        Game.ctx.scale(1, -1) // setting it like that to flip along Y axis\r\n        this.targetY = this.targetY * -1 - (Game.board.frameHeight * VAR.scale)\r\n      } else {\r\n        Game.ctx.scale(-1, 1) // flip along X axis\r\n        this.targetX = this.targetX * -1 - (Game.board.frameWidth * VAR.scale)\r\n      }\r\n    }\r\n\r\n    Game.ctx.drawImage(\r\n      Game.sprite,\r\n      this.data.sx + this.data.frames[this.currentFrame] * Game.board.frameWidth, // dynamic definition to assign next frames\r\n      this.data.sy,\r\n      Game.board.frameWidth,\r\n      Game.board.frameHeight,\r\n      this.targetX,\r\n      this.targetY,\r\n      Game.board.frameWidth * VAR.scale,\r\n      Game.board.frameHeight * VAR.scale\r\n    )\r\n    if (this.data.flip) {\r\n      Game.ctx.restore() // restore previos canvas settings\r\n    }\r\n    this.currentFrame = this.currentFrame + 1 < this.data.frames.length ? this.currentFrame + 1 : 0\r\n    this.timer--\r\n  } else if (this.type == 'solid') { // after explosion\r\n    Bomb.count-- // reduce number of bombs\r\n    this.type = 'empty' // when bomb explodes, it's type is empty\r\n    this.currentFrame = 0\r\n    this.data = Bomb.elements.center // change state of bomb to center (of explosion)\r\n    this.timer = this.data.frames.length // change frames amount to length of explosion\r\n    this.booms = [] // places where flame should appear (4 directions)\r\n    for (let i = 0; i < 4; i++) { // check all directions where flame can appear\r\n      this.axis = i % 2 ? 'tempColumn' : 'tempRow' // i=0 is up, i=1 is right, i=2 is down, i=3 is left\r\n      this.grow = !!(i % 3)\r\n\r\n      this.tempColumn = this.column\r\n      this.tempRow = this.row\r\n\r\n      if (this.axis == 'tempColumn' && this.grow) { // defining what type of graphics should be used when explosion expands left, right etc ...\r\n        this.tempBoomType = 'right_boom'\r\n      } else if (this.axis == 'tempColumn' && !this.grow) {\r\n        this.tempBoomType = 'left_boom'\r\n      } else if (this.axis == 'tempRow' && this.grow) {\r\n        this.tempBoomType = 'down_boom'\r\n      } else if (this.axis == 'tempRow' && !this.grow) {\r\n        this.tempBoomType = 'up_boom'\r\n      }\r\n\r\n      for (let j = 0; j < this.range; j++) {\r\n        this[this.axis] = this[this.axis] + (this.grow ? 1 : -1)\r\n        if (Game.board.b[this.tempRow][this.tempColumn].type != 'solid') {\r\n          if (Game.board.b[this.tempRow][this.tempColumn].koObj) {\r\n            new Crate(this.tempColumn, this.tempRow)\r\n            break\r\n          } else {\r\n            new Bomb(this.tempColumn, this.tempRow, this.tempBoomType + (j == this.range - 1 ? '_end' : ''))\r\n          } // flames ending\r\n        } else if (Game.board.b[this.tempRow][this.tempColumn].subtype == 'bomb' && !Game.board.b[this.tempRow][this.tempColumn].boomType) { // check if there is a bomb\r\n          Game.board.b[this.tempRow][this.tempColumn].timer = 0\r\n        } else {\r\n          break\r\n        }\r\n      }\r\n    }\r\n  } else { // after explosion change to grren field\r\n    Game.board.b[this.row][this.column] = Board.elements.floor\r\n  }\r\n}\r\n","import {\r\n  Game\r\n} from './index.mjs'\r\nimport {\r\n  VAR\r\n} from './VAR.mjs'\r\n\r\nCharacter.count = 0\r\n\r\nexport function Character (inheritance) {\r\n  Character.count++ // controlling how many characters have been generated\r\n  this.id = `char_${Character.count}` // setting specific id to each character\r\n\r\n  if (!inheritance) { // allowed only if given argument is true\r\n    Game.toDraw[this.id] = this // pushing created character into object stroing all characters\r\n  }\r\n\r\n  this.frameWidth = 21 // width of a sprite\r\n  this.frameHeight = 24 // height of a sprite\r\n\r\n  this.modX = -2\r\n  this.modY = -8\r\n\r\n  this.speed = 2\r\n\r\n  this.currentFrame = 0 // current frame of animation\r\n\r\n  this.maxFrameDelay = 2 // properties to slow down animation\r\n  this.currentFrameDelay = 0\r\n}\r\n\r\nCharacter.prototype.draw = function () { // draw method prototype\r\n  if (this.state.slice(-2) == 'go') {\r\n    // char speed depending on his state\r\n    if (this.state == 'down_go') {\r\n      this.y += this.speed\r\n    } else if (this.state == 'right_go') {\r\n      this.x += this.speed\r\n    } else if (this.state == 'up_go') {\r\n      this.y -= this.speed\r\n    } else if (this.state == 'left_go') {\r\n      this.x -= this.speed\r\n    }\r\n\r\n    this.rowAndColumn()\r\n  }\r\n\r\n  // Game.ctx.fillRect(\r\n  //   this.column * Game.board.frameWidth * VAR.scale,\r\n  //   this.row * Game.board.frameHeight * VAR.scale,\r\n  //   Game.board.frameWidth * VAR.scale,\r\n  //   Game.board.frameHeight * VAR.scale\r\n  // )\r\n\r\n  // Game.ctx.fillRect(\r\n  //   this.nextColumn * Game.board.frameWidth * VAR.scale,\r\n  //   this.nextRow * Game.board.frameHeight * VAR.scale,\r\n  //   Game.board.frameWidth * VAR.scale,\r\n  //   Game.board.frameHeight * VAR.scale\r\n  // )\r\n\r\n  if (Game.board.b[this.row][this.column].subtype == 'bomb' && Game.board.b[this.row][this.column].boomType) {\r\n    this.setKO()\r\n  }\r\n\r\n  if (this.states[this.state].flip) { // inverse image if 'flip' property is true\r\n    Game.ctx.save() // saving a given canvas state\r\n    Game.ctx.scale(-1, 1) // inversing canvas\r\n  }\r\n\r\n  Game.ctx.drawImage( // definig what part of image should be clipped\r\n    Game.sprite,\r\n    this.states[this.state].sx + this.states[this.state].f[this.currentFrame] * this.frameWidth,\r\n    this.states[this.state].sy,\r\n    this.frameWidth,\r\n    this.frameHeight,\r\n    this.states[this.state].flip ? (-this.frameWidth - this.modX - this.x) * VAR.scale : (this.x + this.modX) * VAR.scale,\r\n    (this.y + this.modY) * VAR.scale,\r\n    this.frameWidth * VAR.scale,\r\n    this.frameHeight * VAR.scale\r\n  )\r\n  if (this.states[this.state].flip) {\r\n    Game.ctx.restore() // restoring previously saved canvas state\r\n  }\r\n  if (this.currentFrameDelay < this.maxFrameDelay) { // slowing down animation\r\n    this.currentFrameDelay++\r\n  } else {\r\n    this.currentFrameDelay = 0\r\n    if (this.state == 'ko' && this.currentFrame == this.states[this.state].f.length - 1) {\r\n      this.afterKO()\r\n    } else {\r\n      this.currentFrame = this.currentFrame + 1 >= this.states[this.state].f.length ? 0 : this.currentFrame + 1\r\n    }\r\n  }\r\n}\r\n\r\n// adding collision detection for Character\r\nCharacter.prototype.rowAndColumn = function () {\r\n  // compute in which row and in which column character is located\r\n  this.row = Math.round(this.y / Game.board.frameHeight)\r\n  this.column = Math.round(this.x / Game.board.frameWidth)\r\n  if (this.state.slice(-3) == '_go') { // determine on which board element char is\r\n    if (this.state == 'left_go' || this.state == 'right_go') {\r\n      this.nextRow = this.row\r\n      this.nextColumn = this.state == 'left_go' ? Math.floor(this.x / Game.board.frameWidth) : Math.ceil(this.x / Game.board.frameWidth) // round down if movement to left and round up when char moving right\r\n    } else {\r\n      this.nextColumn = this.column\r\n      this.nextRow = this.state == 'up_go' ? Math.floor(this.y / Game.board.frameHeight) : Math.ceil(this.y / Game.board.frameHeight)\r\n    }\r\n    // check if current column and row changes or not && check if next place is empty or not\r\n    if (!(this.row == this.nextRow && this.column == this.nextColumn) && Game.board.b[this.nextRow][this.nextColumn].type != 'empty') {\r\n      this.state = this.state.slice(0, -3)\r\n      this.currentFrame = 0\r\n      // when char hits an obstacle we want to put him on the center of the area\r\n      if (this.row != this.nextRow) {\r\n        this.y = this.row * Game.board.frameHeight\r\n      } else {\r\n        this.x = this.column * Game.board.frameWidth\r\n      }\r\n    } else { // situation when character can walk on certain area - let's center him!\r\n      if (this.row != this.nextRow) { // both ifs are making sure that character is walking in the 'tunnel'\r\n        this.x = this.nextColumn * Game.board.frameWidth\r\n      } else if (this.column != this.nextColumn) {\r\n        this.y = this.nextRow * Game.board.frameHeight\r\n      }\r\n    }\r\n  } else { // if char not moving then don't reasign row and col position\r\n    this.nextRow = this.row\r\n    this.nextColumn = this.column\r\n  }\r\n}\r\n\r\nCharacter.prototype.setKO = function () { // activate death animation\r\n  this.state = 'ko'\r\n}\r\n\r\nCharacter.prototype.afterKO = function () { // delete character (Hero, Enemy ...) from game after death\r\n  delete Game.toDraw[this.id]\r\n}\r\n\r\nexport function Hero () { // deifing main hero\r\n  Character.call(this) // extending Character class\r\n  this.state = 'down' // current animation state of Hero\r\n  this.states = { // definig all possible animation states of Hero\r\n    down: {\r\n      sx: 0,\r\n      sy: 0,\r\n      f: [0]\r\n    },\r\n    down_go: {\r\n      sx: 0,\r\n      sy: 0,\r\n      f: [1, 0, 2, 0]\r\n    },\r\n    left: {\r\n      sx: 63,\r\n      sy: 0,\r\n      f: [0]\r\n    },\r\n    left_go: {\r\n      sx: 63,\r\n      sy: 0,\r\n      f: [1, 0, 2, 0]\r\n    },\r\n    up: {\r\n      sx: 0,\r\n      sy: 24,\r\n      f: [0]\r\n    },\r\n    up_go: {\r\n      sx: 0,\r\n      sy: 24,\r\n      f: [1, 0, 2, 0]\r\n    },\r\n    right: {\r\n      sx: 63,\r\n      sy: 0,\r\n      f: [0],\r\n      flip: true\r\n    }, // flip set up to inverse character graphics\r\n    right_go: {\r\n      sx: 63,\r\n      sy: 0,\r\n      f: [1, 0, 2, 0],\r\n      flip: true\r\n    },\r\n    ko: {\r\n      sx: 0,\r\n      sy: 48,\r\n      f: [0, 1, 0, 1, 0, 1, 2, 3, 4]\r\n    } // death animation\r\n  }\r\n  this.x = Game.board.frameWidth\r\n  this.y = Game.board.frameHeight\r\n\r\n  this.rowAndColumn()\r\n}\r\n\r\nHero.prototype = new Character(true) // extending Character draw method to Hero constructor\r\nHero.prototype.constructor = Hero\r\n\r\nHero.prototype.parent = Character.prototype // define to expand methods\r\n\r\nHero.prototype.updateState = function () {\r\n  this.tempState = this.state // temporary state variable\r\n  if (Game.key_37) { // when arrow left is pressed then change temporary state to left_go\r\n    this.tempState = 'left_go'\r\n  } else if (Game.key_38) { // when arrow left is pressed then change temporary state to left_go\r\n    this.tempState = 'up_go'\r\n  } else if (Game.key_39) { // when arrow left is pressed then change temporary state to left_go\r\n    this.tempState = 'right_go'\r\n  } else if (Game.key_40) { // when arrow left is pressed then change temporary state to left_go\r\n    this.tempState = 'down_go'\r\n  } else if (this.state.slice(-2) == 'go') { // check if current active state was with 'go' ending\r\n    this.tempState = this.state.slice(0, this.state.indexOf('_go')) // slice last 3 digits to be left with static state\r\n  }\r\n  if (this.tempState != this.state) { // check if state has changed\r\n    this.currentFrame = 0\r\n    this.state = this.tempState // reasign state to temporary state\r\n  }\r\n}\r\n\r\nHero.prototype.setKO = function () {\r\n  this.parent.setKO.call(this)\r\n  Game.stop()\r\n}\r\n\r\nHero.prototype.afterKO = function () {\r\n  if (!Game.isOver) {\r\n    Game.isOver = true\r\n    console.log('game over')\r\n  }\r\n}\r\n\r\nHero.prototype.enemyHitTest = function () { // collision detection with enemies\r\n  for (let e in Enemy.all) {\r\n    e = Enemy.all[e]\r\n    if ((this.row == e.row && e.x + Game.board.frameWidth > this.x && e.x < this.x + Game.board.frameWidth) || (this.column == e.column && e.y + Game.board.frameHeight > this.y && e.y < this.y + Game.board.frameHeight)) {\r\n      return true\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\nHero.prototype.draw = function () {\r\n  this.parent.draw.call(this)\r\n  if (this.state != 'ko' && this.enemyHitTest()) {\r\n    this.setKO()\r\n  }\r\n}\r\n\r\nEnemy.all = {}\r\nexport function Enemy (x, y) {\r\n  Character.call(this)\r\n  Enemy.all[this.id] = this // assign id to enemy\r\n  this.state = 'down' // current animation state of Enemy\r\n  this.states = { // definig all possible animation states of Enemy\r\n    down: {\r\n      sx: 0,\r\n      sy: 72,\r\n      f: [0]\r\n    }, // static\r\n    down_go: {\r\n      sx: 0,\r\n      sy: 72,\r\n      f: [1, 0, 2, 0]\r\n    }, // dynamic\r\n    left: {\r\n      sx: 63,\r\n      sy: 24,\r\n      f: [0]\r\n    },\r\n    left_go: {\r\n      sx: 63,\r\n      sy: 24,\r\n      f: [1, 0, 2, 0]\r\n    },\r\n    up: {\r\n      sx: 63,\r\n      sy: 72,\r\n      f: [0]\r\n    },\r\n    up_go: {\r\n      sx: 63,\r\n      sy: 72,\r\n      f: [1, 0, 2, 0]\r\n    },\r\n    right: {\r\n      sx: 63,\r\n      sy: 24,\r\n      f: [0],\r\n      flip: true\r\n    }, // flip set up to inverse character graphics\r\n    right_go: {\r\n      sx: 63,\r\n      sy: 24,\r\n      f: [1, 0, 2, 0],\r\n      flip: true\r\n    },\r\n    ko: {\r\n      sx: 0,\r\n      sy: 96,\r\n      f: [0, 1, 2, 3, 4, 5]\r\n    } // death animation\r\n  }\r\n  this.x = x\r\n  this.y = y\r\n\r\n  this.rowAndColumn()\r\n  this.setDirection()\r\n}\r\n\r\nEnemy.prototype = new Character(true) // extending Character draw method to Hero constructor\r\nEnemy.prototype.constructor = Enemy\r\n\r\nEnemy.prototype.parent = Character.prototype // used to extend method assigned to Character\r\n\r\nEnemy.prototype.setDirection = function () {\r\n  this.canGo = this.canGo || [] // assign array for possible directions or use the one already assigned\r\n  this.canGo.length = 0 // empty the array\r\n  // enemy already has assigned position\r\n  // we have to iterate through all positions around it and check if they are empty of solid\r\n\r\n  for (let i = this.column - 1; i <= this.column + 1; i++) {\r\n    for (let j = this.row - 1; j <= this.row + 1; j++) {\r\n      if (!(i == this.column && j == this.row)) { // don't check position where enemy is alrady situated\r\n        if (i == this.column || j == this.row) { // don't check corners\r\n          if (Game.board.b[j][i].type == 'empty') {\r\n            this.canGo.push({\r\n              x: i,\r\n              y: j\r\n            })\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (this.canGo.length > 0) {\r\n    this.tempPos = this.canGo[VAR.random(0, this.canGo.length - 1)]\r\n\r\n    if (this.column < this.tempPos.x) {\r\n      this.state = 'right_go'\r\n    } else if (this.column > this.tempPos.x) {\r\n      this.state = 'left_go'\r\n    } else if (this.row < this.tempPos.y) {\r\n      this.state = 'down_go'\r\n    } else if (this.row > this.tempPos.y) {\r\n      this.state = 'up_go'\r\n    }\r\n  } else if (this.state.slice(-2) == 'go') {\r\n    this.state = this.state.slice(0, -3)\r\n  }\r\n}\r\n\r\nEnemy.prototype.rowAndColumn = function () { // extending rowAndColumn method\r\n  this.previousState = this.state // saving current state to this.previousState\r\n  this.parent.rowAndColumn.call(this) // assigning this to parent\r\n\r\n  if (this.previousState != this.state && this.state.slice(-2) != 'go' && this.previousState.slice(-2) == 'go') {\r\n    this.setDirection()\r\n  }\r\n}\r\n\r\nEnemy.prototype.afterKO = function () {\r\n  this.parent.afterKO.call(this) // expanding afterKO method\r\n  delete Enemy.all[this.id] // delete enemy from array stoirng it\r\n  let someEnemy = false\r\n  for (let e in Enemy.all) {\r\n    someEnemy = true\r\n    break\r\n  }\r\n  if (!someEnemy) {\r\n    console.log('success')\r\n  }\r\n}\r\n","import {\r\n  Board\r\n} from './Board.mjs'\r\nimport {\r\n  VAR\r\n} from './VAR.mjs'\r\nimport {\r\n  Game\r\n} from './index.mjs'\r\n\r\nexport function Crate (column, row) { // place to put a crate\r\n  this.sx = Board.elements.floor.sx\r\n  this.sy = Board.elements.floor.sy\r\n  this.animSx = 126\r\n  this.animSy = 0\r\n  this.currentFrame = 0\r\n  this.frames = [0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5]\r\n  this.type = 'empty'\r\n  this.subtype = 'crate'\r\n  this.row = row\r\n  this.column = column\r\n\r\n  Game.board.b[row][column] = this\r\n}\r\n\r\nCrate.prototype.draw = function () {\r\n  Game.ctx.drawImage(\r\n    Game.sprite,\r\n    this.animSx + this.frames[this.currentFrame] * Game.board.frameWidth,\r\n    this.animSy,\r\n    Game.board.frameWidth,\r\n    Game.board.frameHeight,\r\n    this.column * Game.board.frameWidth * VAR.scale,\r\n    this.row * Game.board.frameHeight * VAR.scale,\r\n    Game.board.frameWidth * VAR.scale,\r\n    Game.board.frameWidth * VAR.scale\r\n  )\r\n  this.currentFrame++\r\n  if (this.currentFrame >= this.frames.length) {\r\n    Game.board.b[this.row][this.column] = Board.elements.floor // after explosion put floor into bombs place\r\n  }\r\n}\r\n","// variable used to store handy properties used among the way\r\nexport const VAR = {\r\n  fps: 15, // frames per second for animation\r\n  H: 0, // window height\r\n  W: 0, // window width\r\n  scale: 4, // game elements will be loaded in proper scale\r\n  lastTime: 0, // property for rAF\r\n  random: (min, max) => { // ranodm number generator\r\n    return Math.floor(Math.random() * (max - min + 1)) + min\r\n},\r\n  shuffle: function (arr) { // method to shuffle array of emty spaces\r\n    let counter = arr.length\r\n    let temp\r\n    let index\r\n    while (counter > 0) {\r\n      counter--\r\n      index = Math.floor(Math.random() * counter)\r\n      temp = arr[counter]\r\n      arr[counter] = arr[index]\r\n      arr[index] = temp\r\n    }\r\n    return arr\r\n}\r\n}\r\n","import {\r\n  Character,\r\n  Hero,\r\n  Enemy\r\n} from './Characters.mjs'\r\nimport {\r\n  VAR\r\n} from './VAR.mjs'\r\nimport {\r\n  Board\r\n} from './Board.mjs'\r\nimport {\r\n  Bomb\r\n} from './Bomb.mjs'\r\n\r\ndocument.addEventListener('DOMContentLoaded', () => {\r\n  Game.sprite = new Image()\r\n  Game.sprite.onload = Game.init // makes sure that init() is launched after image is loaded\r\n  Game.sprite.src = 'dist/img/bombe.png'\r\n})\r\n\r\n// object containg basic game properties\r\nexport let Game = {\r\n  init () {\r\n    Game.canvas = document.createElement('canvas') // create canvas\r\n    Game.ctx = Game.canvas.getContext('2d') // get canvas 2d context\r\n    Game.board = new Board()\r\n    Game.layout() // launch function to resize W and H based on window inner dimensions\r\n    window.addEventListener('resize', Game.layout) // launch layout() function on window resize\r\n    document.body.appendChild(Game.canvas) // append canvas to DOM\r\n\r\n    Game.toDraw = {} // object to store all characters\r\n\r\n    Game.hero = new Hero()\r\n\r\n    let tempEmpty\r\n    // create 5 enemies in random places\r\n    for (let i = 0; i < 5; i++) {\r\n      tempEmpty = Game.board.getEmptySpace()\r\n      new Enemy(tempEmpty.x * Game.board.frameWidth, tempEmpty.y * Game.board.frameHeight)\r\n    }\r\n\r\n    // add event listeners for char sterring\r\n\r\n    window.addEventListener('keydown', Game.onKey)\r\n    window.addEventListener('keyup', Game.onKey)\r\n\r\n    Game.animationLoop() // launch game animation loop\r\n  },\r\n\r\n  stop: () => {\r\n    window.removeEventListener('keydown', Game.onKey)\r\n    window.removeEventListener('keyup', Game.onKey)\r\n  },\r\n\r\n  onKey: (e) => {\r\n    if (e.keyCode >= 37 && e.keyCode <= 40 || e.keyCode == 32) { // use only arrows and space in game\r\n      e.preventDefault() // turn off standard key actions\r\n      if (e.type == 'keydown' && !Game[`key_${e.keyCode}`]) { // when key has been pressed\r\n        Game[`key_${e.keyCode}`] = true // set key to work\r\n        if (e.keyCode >= 37 && e.keyCode <= 40) { // if any arrow was pressed then make sure to disable previously pressed arrow\r\n          for (let i = 37; i <= 40; i++) {\r\n            if (i != e.keyCode) {\r\n              Game[`key_${i}`] = false\r\n            }\r\n          }\r\n          Game.hero.updateState()\r\n        } else {\r\n          new Bomb(Game.hero.column, Game.hero.row)\r\n        }\r\n        Game.hero.updateState() // launch update function when key is pressed (conditions above)\r\n      } else if (e.type == 'keyup') { // update state when key is released as well (char is standing)\r\n        Game[`key_${e.keyCode}`] = false\r\n        Game.hero.updateState()\r\n      }\r\n    }\r\n  },\r\n\r\n  layout: () => {\r\n    VAR.H = window.innerHeight // get window dimensions dynamically\r\n    VAR.W = window.innerWidth // as above\r\n\r\n    VAR.scale = Math.max(1, Math.min(\r\n      Math.floor(VAR.H / (Game.board.frameWidth * Game.board.b[0].length)),\r\n      Math.floor(VAR.W / (Game.board.frameHeight * Game.board.b.length))\r\n    ))\r\n\r\n    Game.canvas.width = Math.round(VAR.scale * Game.board.frameWidth * Game.board.b[0].length) // as above\r\n    Game.canvas.height = Math.round(VAR.scale * Game.board.frameHeight * Game.board.b.length) // set canvas dimensions based on window dimensions\r\n\r\n    Game.canvas.style[Modernizr.prefixed('transform')] = `translate(${Math.round((VAR.W - Game.canvas.width) / 2)}px, ${Math.round((VAR.H - Game.canvas.height) / 2)}px)`\r\n\r\n    // 'translate('+Math.round((VAR.W-Game.canvas.width)/2) + 'px,' +Math.round((VAR.H-Game.canvas.height)/2)+'px)';\r\n    Game.ctx.imageSmoothingEnabled = false // character pixels are super sharp\r\n    Game.ctx.mozImageSmoothingEnabled = false\r\n    Game.ctx.oImageSmoothingEnabled = false\r\n    Game.ctx.webkitImageSmoothingEnabled = false\r\n  },\r\n\r\n  animationLoop: (time) => {\r\n    requestAnimationFrame(Game.animationLoop)\r\n    // limit fps to desired rate\r\n    if (time - VAR.lastTime >= 1000 / VAR.fps) {\r\n      VAR.lastTime = time\r\n\r\n      Game.ctx.clearRect(0, 0, VAR.W, VAR.H)\r\n\r\n      Game.board.draw()\r\n\r\n      for (const i in Game.toDraw) {\r\n        Game.toDraw[i].draw()\r\n      }\r\n    }\r\n  }\r\n}\r\n"],"sourceRoot":""}