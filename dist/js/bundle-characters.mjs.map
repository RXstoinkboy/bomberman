{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/js/Board.mjs","webpack:///./src/js/Bomb.mjs","webpack:///./src/js/Characters.mjs","webpack:///./src/js/Crate.mjs","webpack:///./src/js/VAR.mjs","webpack:///./src/js/index.mjs"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAEmB;AAGE;AACe;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACO;AACP;AACA;AACA,6BAA6B,4CAAG,yCAAyC;AACzE;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA,wCAAwC;AACxC,wBAAwB;AACxB;;AAEA,iBAAiB,gBAAgB,OAAO;AACxC,oBAAoB;AACpB,mBAAmB,mBAAmB,OAAO;AAC7C;AACA,2FAA2F;;AAE3F;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,qBAAqB,4CAAG,2BAA2B;AACnD;;AAEA;AACA;AACA;;AAEA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,mB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AEA;AACA;AACA;AACA,iCAAiC,+CAAI;AACrC,oCAAoC,+CAAI;AACxC,sCAAsC;AACtC;AACA;AACA,sEAAsE,+CAAI,wCAAwC,+CAAI,mBAAmB;AACzI,KAAK;AACL;AACA,iEAAiE,+CAAI,yCAAyC,+CAAI;AAClH;AACA;AACA,yEAAyE,+CAAI;AAC7E;AACA;AACA;AACA;AACA,4BAA4B,+CAAI;AAChC,OAAO;AACP,+BAA+B,+CAAI;AACnC;AACA,KAAK,OAAO;AACZ,qCAAqC;AACrC,mCAAmC,+CAAI;AACvC,OAAO;AACP,gCAAgC,+CAAI;AACpC;AACA;AACA,GAAG,OAAO;AACV;AACA;AACA;AACA;;AAEO,iBAAiB;AACxB,uBAAuB;AACvB,sBAAsB;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,WAAW,+CAAI;AACf,WAAW,+CAAI;;AAEf;AACA;;AAEA,qCAAqC;AACrC;;AAEA;AACA,8BAA8B;AAC9B,MAAM,+CAAI,UAAU;AACpB;AACA,GAAG,UAAU,+CAAI,UAAU;AAC3B;AACA,GAAG,UAAU,+CAAI,UAAU;AAC3B;AACA,GAAG,UAAU,+CAAI,UAAU;AAC3B;AACA,GAAG,yCAAyC;AAC5C,oEAAoE;AACpE;AACA,qCAAqC;AACrC;AACA,gCAAgC;AAChC;AACA;;AAEA;AACO;AACP;AACA,4BAA4B;AAC5B,sBAAsB;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AA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","file":"bundle-characters.mjs","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/js/Characters.mjs\");\n","import {\r\n  VAR,\r\n} from './VAR.mjs';\r\nimport {\r\n  Game,\r\n} from './index.mjs';\r\nimport { Crate } from './Crate.mjs';\r\n\r\nBoard.templates = [ // creating board templates here\r\n  [\r\n    'WWWWWWWWWWWWWWW',\r\n    'W             W',\r\n    'W X X X X X X W',\r\n    'W             W',\r\n    'W X X X X X X W',\r\n    'W             W',\r\n    'W X X X X X X W',\r\n    'W             W',\r\n    'W X X X X X X W',\r\n    'W             W',\r\n    'WWWWWWWWWWWWWWW',\r\n  ],\r\n  [\r\n    'WWWWWWWWWWWWWWW',\r\n    'W             W',\r\n    'W X XXX XXX X W',\r\n    'W             W',\r\n    'W X X X X X X W',\r\n    'W X         X W',\r\n    'W X X X X X X W',\r\n    'W             W',\r\n    'W XXX X X XXX W',\r\n    'W             W',\r\n    'WWWWWWWWWWWWWWW',\r\n  ],\r\n];\r\n\r\n// define all board elements\r\n// type: defines what kind of material it is:\r\n// empty - you can walk on it\r\n// soft - you can destroy it\r\n// solid - undestructible\r\nBoard.elements = {\r\n  floor: {\r\n    sx: 174,\r\n    sy: 16,\r\n    type: 'empty',\r\n    subtype: 'board',\r\n  },\r\n  W: {\r\n    sx: 190,\r\n    sy: 16,\r\n    type: 'solid',\r\n    subtype: 'board',\r\n  }, // outer wall\r\n  X: {\r\n    sx: 206,\r\n    sy: 16,\r\n    type: 'solid',\r\n    subtype: 'board',\r\n  }, // inner wall\r\n  box: {\r\n    sx: 126,\r\n    sy: 0,\r\n    type: 'soft',\r\n    subtype: 'board',\r\n    koObj: 'Crate',\r\n  },\r\n};\r\nexport function Board() {\r\n  this.frameWidth = 16;\r\n  this.frameHeight = 16;\r\n  this.parse(Board.templates[VAR.random(0, Board.templates.length - 1)]); // pick rundom board from our templates and convert it into right format\r\n  // add boxes on the board\r\n  for (let i = 0; i < 20; i++) {\r\n    this.addCrate();\r\n  }\r\n}\r\n\r\nBoard.prototype.parse = function (arr) { // convert string board to array of arrays with objects inside\r\n  this.emptySpaces = []; // array to store all exisiting empty places (grass) on board\r\n  this.b = [];\r\n\r\n  for (let i = 0; i < arr.length; i++) { // iterate through each raw of the board\r\n    this.b.push([]); // create array for each row of the board\r\n    for (let j = 0; j < arr[i].length; j++) { // iterate through each element (letter) in each row\r\n      // push corresponding object definition in place of a specific letter key\r\n      this.b[i].push(Board.elements[arr[i].charAt(j) == ' ' ? 'floor' : arr[i].charAt(j)]); // pick appropriate obj definition from Board.elements\r\n\r\n      if (this.b[i][j].type === 'empty' && !(i == 1 && j == 1) && !(i == 2 && j == 1) && !(i == 1 && j == 2)) {\r\n        this.emptySpaces.push({\r\n          x: j,\r\n          y: i,\r\n        });\r\n      }\r\n    }\r\n  }\r\n  this.emptySpaces = VAR.shuffle(this.emptySpaces); // shuffle array storing empty spaces\r\n};\r\n\r\nBoard.prototype.getEmptySpace = function () {\r\n  return this.emptySpaces.length > 0 ? this.emptySpaces.shift() : null;\r\n};\r\n\r\nBoard.prototype.addCrate = function () { // adding crate\r\n  const position = this.getEmptySpace();\r\n  if (position) {\r\n    this.b[position.y][position.x] = Board.elements.box;\r\n  }\r\n};\r\n\r\nBoard.prototype.draw = function () {\r\n  for (let i = 0; i < this.b.length; i++) { // iterate through each row\r\n    for (let j = 0; j < this.b[i].length; j++) { // iterate through each element in each row\r\n      Game.ctx.drawImage( // draw method\r\n        Game.sprite, // image source\r\n        this.b[i][j].sx, // coords\r\n        this.b[i][j].sy,\r\n        this.frameWidth, // size\r\n        this.frameHeight,\r\n        j * this.frameWidth * VAR.scale, // where to put it on canvas\r\n        i * this.frameHeight * VAR.scale,\r\n        this.frameWidth * VAR.scale, // how big is the drawn image\r\n        this.frameHeight * VAR.scale,\r\n      );\r\n      if (this.b[i][j].subtype == 'board') { // drawing bombs\r\n        this.b[i][j].draw();\r\n      }\r\n    }\r\n  }\r\n};\r\n","import {\r\n  Game,\r\n} from './index.mjs';\r\nimport {\r\n  Board,\r\n} from './Board.mjs';\r\nimport {\r\n  VAR,\r\n} from './VAR.mjs';\r\n\r\nBomb.count = 0;\r\nBomb.maxCount = 2;\r\nBomb.elements = { // bomb states: before and after explosions\r\n  bomb: {\r\n    sx: 126,\r\n    sy: 16,\r\n    frames: [0, 0, 1, 1, 2, 2],\r\n  },\r\n  center: {\r\n    sx: 126,\r\n    sy: 64,\r\n    frames: [0, 0, 1, 1, 2, 2, 3, 3, 2, 2, 1, 1, 0, 0],\r\n  }, // explode and disapear\r\n  up_boom: {\r\n    sx: 126,\r\n    sy: 96,\r\n    frames: [0, 0, 1, 1, 2, 2, 3, 3, 2, 2, 1, 1, 0, 0],\r\n  },\r\n  down_boom: {\r\n    sx: 126,\r\n    sy: 96,\r\n    frames: [0, 0, 1, 1, 2, 2, 3, 3, 2, 2, 1, 1, 0, 0],\r\n  },\r\n  right_boom: {\r\n    sx: 126,\r\n    sy: 48,\r\n    frames: [0, 0, 1, 1, 2, 2, 3, 3, 2, 2, 1, 1, 0, 0],\r\n  },\r\n  left_boom: {\r\n    sx: 126,\r\n    sy: 48,\r\n    frames: [0, 0, 1, 1, 2, 2, 3, 3, 2, 2, 1, 1, 0, 0],\r\n  },\r\n  up_boom_end: {\r\n    sx: 126,\r\n    sy: 80,\r\n    frames: [0, 0, 1, 1, 2, 2, 3, 3, 2, 2, 1, 1, 0, 0],\r\n  },\r\n  down_boom_end: {\r\n    sx: 126,\r\n    sy: 80,\r\n    frames: [0, 0, 1, 1, 2, 2, 3, 3, 2, 2, 1, 1, 0, 0],\r\n    flip: true,\r\n  },\r\n  left_boom_end: {\r\n    sx: 126,\r\n    sy: 32,\r\n    frames: [0, 0, 1, 1, 2, 2, 3, 3, 2, 2, 1, 1, 0, 0],\r\n  },\r\n  right_boom_end: {\r\n    sx: 126,\r\n    sy: 32,\r\n    frames: [0, 0, 1, 1, 2, 2, 3, 3, 2, 2, 1, 1, 0, 0],\r\n    flip: true,\r\n  },\r\n};\r\n\r\nexport function Bomb(column, row, boom_type) {\r\n  if ((Bomb.count < Bomb.maxCount && Game.board.b[row][column].type != 'bomb') || boom_type) {\r\n    if (!boom_type) {\r\n      Bomb.count++;\r\n    }\r\n    this.boom_type = boom_type;\r\n    this.type = boom_type ? 'empty' : 'solid'; // make sure that you can't walk over a bomb before it explodes\r\n    this.subtype = 'bomb';\r\n    this.data = !boom_type ? Bomb.elements.bomb : Bomb.elements[boom_type];\r\n    this.sx = Board.elements.floor.sx;\r\n    this.sy = Board.elements.floor.sy;\r\n    this.bombSx = 126; // sprite position\r\n    this.bombSy = 16; // sprite position\r\n    this.frames = [0, 0, 1, 1, 2, 2];\r\n    this.currentFrame = 0;\r\n    this.column = column;\r\n    this.row = row;\r\n\r\n    this.timer = boom_type ? this.data.frames.length : 30; // bomb should explode after 30 frames\r\n    this.range = 2; // 2 blocks range of explosion\r\n\r\n    Game.board.b[this.row][this.column] = this; // changing game greenfield from empty to bomb\r\n  }\r\n}\r\n\r\nBomb.prototype.draw = function () {\r\n  if (this.timer > 0) {\r\n    this.targetX = this.column * Game.board.frameWidth * VAR.scale;\r\n    this.targetY = this.row * Game.board.frameHeight * VAR.scale;\r\n\r\n    if (this.data.flip) {\r\n      Game.ctx.save(); // save all vanvas settings\r\n      if (this.boom_type == 'down_boom_end') {\r\n        Game.ctx.scale(1, -1); // setting it like that to flip along Y axis\r\n        this.targetY = this.targetY * -1 - (Game.board.frameHeight * VAR.scale);\r\n      } else {\r\n        Game.ctx.scale(-1, 1); // flip along X axis\r\n        this.targetX = this.targetX * -1 - (Game.board.frameWidth * VAR.scale);\r\n      }\r\n    }\r\n\r\n    Game.ctx.drawImage(\r\n      Game.sprite,\r\n      this.data.sx + this.data.frames[this.currentFrame] * Game.board.frameWidth, // dynamic definition to assign next frames\r\n      this.data.sy,\r\n      Game.board.frameWidth,\r\n      Game.board.frameHeight,\r\n      this.targetX,\r\n      this.targetY,\r\n      Game.board.frameWidth * VAR.scale,\r\n      Game.board.frameHeight * VAR.scale,\r\n    );\r\n    if (this.data.flip) {\r\n      Game.ctx.restore(); // restore previos canvas settings\r\n    }\r\n    this.currentFrame = this.currentFrame + 1 < this.data.frames.length ? this.currentFrame + 1 : 0;\r\n    this.timer--;\r\n  } else if (this.type == 'solid') { // after explosion\r\n    Bomb.count--; // reduce number of bombs\r\n    this.type = 'empty'; // when bomb explodes, it's type is empty\r\n    this.currentFrame = 0;\r\n    this.data = Bomb.elements.center; // change state of bomb to center (of explosion)\r\n    this.timer = this.data.frames.length; // change frames amount to length of explosion\r\n    this.booms = []; // places where flame should appear (4 directions)\r\n    for (let i = 0; i < 4; i++) { // check all directions where flame can appear\r\n      this.axis = i % 2 ? 'tempColumn' : 'tempRow'; // i=0 is up, i=1 is right, i=2 is down, i=3 is left\r\n      this.grow = !!(i % 3);\r\n\r\n      this.tempColumn = this.column;\r\n      this.tempRow = this.row;\r\n\r\n      if (this.axis == 'tempColumn' && this.grow) { // defining what type of graphics should be used when explosion expands left, right etc ...\r\n        this.tempBoomType = 'right_boom';\r\n      } else if (this.axis == 'tempColumn' && !this.grow) {\r\n        this.tempBoomType = 'left_boom';\r\n      } else if (this.axis == 'tempRow' && this.grow) {\r\n        this.tempBoomType = 'down_boom';\r\n      } else if (this.axis == 'tempRow' && !this.grow) {\r\n        this.tempBoomType = 'up_boom';\r\n      }\r\n\r\n      for (let j = 0; j < this.range; j++) {\r\n        this[this.axis] = this[this.axis] + (this.grow ? 1 : -1);\r\n        if (Game.board.b[this.tempRow][this.tempColumn].type != 'solid') {\r\n          if (Game.board.b[this.tempRow][this.tempColumn].koObj) {\r\n            new window[Game.board.b[this.tempRow][this.tempColumn].koObj](this.tempColumn, this.tempRow);\r\n            break;\r\n          } else {\r\n            new Bomb(this.tempColumn, this.tempRow, this.tempBoomType + (j == this.range - 1 ? '_end' : ''));\r\n          } // flames ending\r\n\r\n        } else if (Game.board.b[this.tempRow][this.tempColumn].subtype == 'bomb' && !Game.board.b[this.tempRow][this.tempColumn].boom_type) { // check if there is a bomb\r\n          Game.board.b[this.tempRow][this.tempColumn].timer = 0;\r\n        } else {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  } else { // after explosion change to grren field\r\n    Game.board.b[this.row][this.column] = Board.elements.floor;\r\n  }\r\n};\r\n","import {\r\n  Game,\r\n} from './index.mjs';\r\nimport {\r\n  VAR,\r\n} from './VAR.mjs';\r\n\r\nCharacter.count = 0;\r\n\r\nexport function Character(inheritance) {\r\n  Character.count++; // controlling how many characters have been generated\r\n  this.id = `char_${Character.count}`; // setting specific id to each character\r\n\r\n  if (!inheritance) { // allowed only if given argument is true\r\n    Game.toDraw[this.id] = this; // pushing created character into object stroing all characters\r\n  }\r\n\r\n  this.frameWidth = 21; // width of a sprite\r\n  this.frameHeight = 24; // height of a sprite\r\n\r\n  this.modX = -2;\r\n  this.modY = -8;\r\n\r\n  this.speed = 2;\r\n\r\n  this.currentFrame = 0; // current frame of animation\r\n\r\n  this.maxFrameDelay = 2; // properties to slow down animation\r\n  this.currentFrameDelay = 0;\r\n}\r\n\r\nCharacter.prototype.draw = function () { // draw method prototype\r\n  if (this.state.slice(-2) == 'go') {\r\n    // char speed depending on his state\r\n    if (this.state == 'down_go') {\r\n      this.y += this.speed;\r\n    } else if (this.state == 'right_go') {\r\n      this.x += this.speed;\r\n    } else if (this.state == 'up_go') {\r\n      this.y -= this.speed;\r\n    } else if (this.state == 'left_go') {\r\n      this.x -= this.speed;\r\n    }\r\n\r\n    this.rowAndColumn();\r\n  }\r\n\r\n  // Game.ctx.fillRect(\r\n  //     this.column*Game.board.frameWidth*VAR.scale,\r\n  //     this.row*Game.board.frameHeight*VAR.scale,\r\n  //     Game.board.frameWidth*VAR.scale,\r\n  //     Game.board.frameHeight*VAR.scale\r\n  //     );\r\n\r\n  //     Game.ctx.fillRect(\r\n  //         this.nextColumn*Game.board.frameWidth*VAR.scale,\r\n  //         this.nextRow*Game.board.frameHeight*VAR.scale,\r\n  //         Game.board.frameWidth*VAR.scale,\r\n  //         Game.board.frameHeight*VAR.scale\r\n  //         );\r\n\r\n  if (this.states[this.state].flip) { // inverse image if 'flip' property is true\r\n    Game.ctx.save(); // saving a given canvas state\r\n    Game.ctx.scale(-1, 1); // inversing canvas\r\n  }\r\n\r\n  Game.ctx.drawImage( // definig what part of image should be clipped\r\n    Game.sprite,\r\n    this.states[this.state].sx + this.states[this.state].f[this.currentFrame] * this.frameWidth,\r\n    this.states[this.state].sy,\r\n    this.frameWidth,\r\n    this.frameHeight,\r\n    this.states[this.state].flip ? (-this.frameWidth - this.modX - this.x) * VAR.scale : (this.x + this.modX) * VAR.scale,\r\n    (this.y + this.modY) * VAR.scale,\r\n    this.frameWidth * VAR.scale,\r\n    this.frameHeight * VAR.scale,\r\n  );\r\n  if (this.states[this.state].flip) {\r\n    Game.ctx.restore(); // restoring previously saved canvas state\r\n  }\r\n  if (this.currentFrameDelay < this.maxFrameDelay) { // slowing down animation\r\n    this.currentFrameDelay++;\r\n  } else {\r\n    this.currentFrameDelay = 0;\r\n    this.currentFrame = this.currentFrame + 1 >= this.states[this.state].f.length ? 0 : this.currentFrame + 1;\r\n  }\r\n};\r\n\r\n// adding collision detection for Character\r\nCharacter.prototype.rowAndColumn = function () {\r\n  // compute in which row and in which column character is located\r\n  this.row = Math.round(this.y / Game.board.frameHeight);\r\n  this.column = Math.round(this.x / Game.board.frameWidth);\r\n  if (this.state.slice(-3) == '_go') { // determine on which board element char is\r\n    if (this.state == 'left_go' || this.state == 'right_go') {\r\n      this.nextRow = this.row;\r\n      this.nextColumn = this.state == 'left_go' ? Math.floor(this.x / Game.board.frameWidth) : Math.ceil(this.x / Game.board.frameWidth); // round down if movement to left and round up when char moving right\r\n    } else {\r\n      this.nextColumn = this.column;\r\n      this.nextRow = this.state == 'up_go' ? Math.floor(this.y / Game.board.frameHeight) : Math.ceil(this.y / Game.board.frameHeight);\r\n    }\r\n    // check if current column and row changes or not && check if next place is empty or not\r\n    if (!(this.row == this.nextRow && this.column == this.nextColumn) && Game.board.b[this.nextRow][this.nextColumn].type != 'empty') {\r\n      this.state = this.state.slice(0, -3);\r\n      this.currentFrame = 0;\r\n      // when char hits an obstacle we want to put him on the center of the area\r\n      if (this.row != this.nextRow) {\r\n        this.y = this.row * Game.board.frameHeight;\r\n      } else {\r\n        this.x = this.column * Game.board.frameWidth;\r\n      }\r\n    } else { // situation when character can walk on certain area - let's center him!\r\n      if (this.row != this.nextRow) { // both ifs are making sure that character is walking in the 'tunnel'\r\n        this.x = this.nextColumn * Game.board.frameWidth;\r\n      } else if (this.column != this.nextColumn) {\r\n        this.y = this.nextRow * Game.board.frameHeight;\r\n      }\r\n    }\r\n  } else { // if char not moving then don't reasign row and col position\r\n    this.nextRow = this.row;\r\n    this.nextColumn = this.column;\r\n  }\r\n};\r\n\r\nexport function Hero() { // deifing main hero\r\n  Character.call(this); // extending Character class\r\n  this.state = 'down'; // current animation state of Hero\r\n  this.states = { // definig all possible animation states of Hero\r\n    down: {\r\n      sx: 0,\r\n      sy: 0,\r\n      f: [0],\r\n    },\r\n    down_go: {\r\n      sx: 0,\r\n      sy: 0,\r\n      f: [1, 0, 2, 0],\r\n    },\r\n    left: {\r\n      sx: 63,\r\n      sy: 0,\r\n      f: [0],\r\n    },\r\n    left_go: {\r\n      sx: 63,\r\n      sy: 0,\r\n      f: [1, 0, 2, 0],\r\n    },\r\n    up: {\r\n      sx: 0,\r\n      sy: 24,\r\n      f: [0],\r\n    },\r\n    up_go: {\r\n      sx: 0,\r\n      sy: 24,\r\n      f: [1, 0, 2, 0],\r\n    },\r\n    right: {\r\n      sx: 63,\r\n      sy: 0,\r\n      f: [0],\r\n      flip: true,\r\n    }, // flip set up to inverse character graphics\r\n    right_go: {\r\n      sx: 63,\r\n      sy: 0,\r\n      f: [1, 0, 2, 0],\r\n      flip: true,\r\n    },\r\n    ko: {\r\n      sx: 0,\r\n      sy: 48,\r\n      f: [0, 1, 0, 1, 0, 1, 2, 3, 4],\r\n    }, // death animation\r\n  };\r\n  this.x = Game.board.frameWidth;\r\n  this.y = Game.board.frameHeight;\r\n\r\n  this.rowAndColumn();\r\n}\r\n\r\nHero.prototype = new Character(true); // extending Character draw method to Hero constructor\r\nHero.prototype.constructor = Hero;\r\n\r\nHero.prototype.updateState = function () {\r\n  this.tempState = this.state; // temporary state variable\r\n  if (Game.key_37) { // when arrow left is pressed then change temporary state to left_go\r\n    this.tempState = 'left_go';\r\n  } else if (Game.key_38) { // when arrow left is pressed then change temporary state to left_go\r\n    this.tempState = 'up_go';\r\n  } else if (Game.key_39) { // when arrow left is pressed then change temporary state to left_go\r\n    this.tempState = 'right_go';\r\n  } else if (Game.key_40) { // when arrow left is pressed then change temporary state to left_go\r\n    this.tempState = 'down_go';\r\n  } else if (this.state.slice(-2) == 'go') { // check if current active state was with 'go' ending\r\n    this.tempState = this.state.slice(0, this.state.indexOf('_go')); // slice last 3 digits to be left with static state\r\n  }\r\n  if (this.tempState != this.state) { // check if state has changed\r\n    this.currentFrame = 0;\r\n    this.state = this.tempState; // reasign state to temporary state\r\n  }\r\n};\r\n\r\nEnemy.all = {};\r\nexport function Enemy(x, y) {\r\n  Character.call(this);\r\n  Enemy.all[this.id] = this; // assign id to enemy\r\n  this.state = 'down'; // current animation state of Enemy\r\n  this.states = { // definig all possible animation states of Enemy\r\n    down: {\r\n      sx: 0,\r\n      sy: 72,\r\n      f: [0],\r\n    }, // static\r\n    down_go: {\r\n      sx: 0,\r\n      sy: 72,\r\n      f: [1, 0, 2, 0],\r\n    }, // dynamic\r\n    left: {\r\n      sx: 63,\r\n      sy: 24,\r\n      f: [0],\r\n    },\r\n    left_go: {\r\n      sx: 63,\r\n      sy: 24,\r\n      f: [1, 0, 2, 0],\r\n    },\r\n    up: {\r\n      sx: 63,\r\n      sy: 72,\r\n      f: [0],\r\n    },\r\n    up_go: {\r\n      sx: 63,\r\n      sy: 72,\r\n      f: [1, 0, 2, 0],\r\n    },\r\n    right: {\r\n      sx: 63,\r\n      sy: 24,\r\n      f: [0],\r\n      flip: true,\r\n    }, // flip set up to inverse character graphics\r\n    right_go: {\r\n      sx: 63,\r\n      sy: 24,\r\n      f: [1, 0, 2, 0],\r\n      flip: true,\r\n    },\r\n    ko: {\r\n      sx: 0,\r\n      sy: 96,\r\n      f: [0, 1, 2, 3, 4, 5],\r\n    }, // death animation\r\n  };\r\n  this.x = x;\r\n  this.y = y;\r\n\r\n  this.rowAndColumn();\r\n  this.setDirection();\r\n}\r\n\r\nEnemy.prototype = new Character(true); // extending Character draw method to Hero constructor\r\nEnemy.prototype.constructor = Enemy;\r\n\r\nEnemy.prototype.parent = Character.prototype; // used to extend method assigned to Character\r\n\r\nEnemy.prototype.setDirection = function () {\r\n  this.canGo = this.canGo || []; // assign array for possible directions or use the one already assigned\r\n  this.canGo.length = 0; // empty the array\r\n  // enemy already has assigned position\r\n  // we have to iterate through all positions around it and check if they are empty of solid\r\n\r\n  for (let i = this.column - 1; i <= this.column + 1; i++) {\r\n    for (let j = this.row - 1; j <= this.row + 1; j++) {\r\n      if (!(i == this.column && j == this.row)) { // don't check position where enemy is alrady situated\r\n        if (i == this.column || j == this.row) { // don't check corners\r\n          if (Game.board.b[j][i].type == 'empty') {\r\n            this.canGo.push({\r\n              x: i,\r\n              y: j,\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (this.canGo.length > 0) {\r\n    this.tempPos = this.canGo[VAR.random(0, this.canGo.length - 1)];\r\n\r\n    if (this.column < this.tempPos.x) {\r\n      this.state = 'right_go';\r\n    } else if (this.column > this.tempPos.x) {\r\n      this.state = 'left_go';\r\n    } else if (this.row < this.tempPos.y) {\r\n      this.state = 'down_go';\r\n    } else if (this.row > this.tempPos.y) {\r\n      this.state = 'up_go';\r\n    }\r\n  } else if (this.state.slice(-2) == 'go') {\r\n    this.state = this.state.slice(0, -3);\r\n  }\r\n};\r\n\r\nEnemy.prototype.rowAndColumn = function () { // extending rowAndColumn method\r\n  this.previousState = this.state; // saving current state to this.previousState\r\n  this.parent.rowAndColumn.call(this); // assigning this to parent\r\n\r\n  if (this.previousState != this.state && this.state.slice(-2) != 'go' && this.previousState.slice(-2) == 'go') {\r\n    this.setDirection();\r\n  }\r\n};\r\n","import {\r\n  Board,\r\n} from './Board.mjs';\r\nimport {\r\n  VAR,\r\n} from './VAR.mjs';\r\nimport {\r\n  Game,\r\n} from './index.mjs';\r\n\r\nexport function Crate(column, row) { // place to put a crate\r\n  this.sx = Board.elements.floor.sx;\r\n  this.sy = Board.elements.floor.sy;\r\n  this.animSx = 126;\r\n  this.animSy = 0;\r\n  this.currentFrame = 0;\r\n  this.frames = [0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5];\r\n  this.type = 'empty';\r\n  this.subtype = 'crate';\r\n  this.row;\r\n  this.column = column;\r\n\r\n  Game.board.b[row][column] = this;\r\n}\r\n\r\nCrate.prototype.draw = function () {\r\n  Game.ctx.drawImage(\r\n    Game.sprite,\r\n    this.animSx * this.frames[this.currentFrame] * Game.board.frameWidth,\r\n    this.animSy,\r\n    Game.board.frameWidth,\r\n    Game.board.frameHeight,\r\n    this.column * Game.board.frameWidth * VAR.scale,\r\n    this.row * Game.board.frameHeight * VAR.scale,\r\n    Game.board.frameWidth * VAR.scale,\r\n    Game.board.frameWidth * VAR.scale,\r\n  );\r\n  this.currentFrame++;\r\n  if (this.currentFrame >= this.frames.length) {\r\n    Game.board.b[this.row][this.column] = Board.elements.floor; // after explosion put floor into bombs place\r\n  }\r\n};\r\n","// variable used to store handy properties used among the way\r\nexport const VAR = {\r\n  fps: 15, // frames per second for animation\r\n  H: 0, // window height\r\n  W: 0, // window width\r\n  scale: 4, // game elements will be loaded in proper scale\r\n  lastTime: 0, // property for rAF\r\n  random: (min, max) => { // ranodm number generator\r\n    return Math.floor(Math.random() * (max - min + 1)) + min\r\n},\r\n  shuffle: function (arr) { // method to shuffle array of emty spaces\r\n    let counter = arr.length\r\n    let temp\r\n    let index\r\n    while (counter > 0) {\r\n      counter--\r\n      index = Math.floor(Math.random() * counter)\r\n      temp = arr[counter]\r\n      arr[counter] = arr[index]\r\n      arr[index] = temp\r\n    }\r\n    return arr\r\n}\r\n}\r\n","import {\r\n  Character,\r\n  Hero,\r\n  Enemy,\r\n} from './Characters.mjs';\r\nimport {\r\n  VAR,\r\n} from './VAR.mjs';\r\nimport {\r\n  Board,\r\n} from './Board.mjs';\r\nimport {\r\n  Bomb,\r\n} from './Bomb.mjs';\r\nimport { Crate } from './Crate.mjs';\r\n\r\ndocument.addEventListener('DOMContentLoaded', () => {\r\n  Game.sprite = new Image();\r\n  Game.sprite.onload = Game.init; // makes sure that init() is launched after image is loaded\r\n  Game.sprite.src = 'dist/img/bombe.png';\r\n});\r\n\r\n// object containg basic game properties\r\nexport let Game = {\r\n  init() {\r\n    Game.canvas = document.createElement('canvas'); // create canvas\r\n    Game.ctx = Game.canvas.getContext('2d'); // get canvas 2d context\r\n    Game.board = new Board();\r\n    Game.layout(); // launch function to resize W and H based on window inner dimensions\r\n    window.addEventListener('resize', Game.layout); // launch layout() function on window resize\r\n    document.body.appendChild(Game.canvas); // append canvas to DOM\r\n\r\n    Game.toDraw = {}; // object to store all characters\r\n\r\n    Game.hero = new Hero();\r\n\r\n    let tempEmpty;\r\n    // create 5 enemies in random places\r\n    for (let i = 0; i < 5; i++) {\r\n      tempEmpty = Game.board.getEmptySpace();\r\n      new Enemy(tempEmpty.x * Game.board.frameWidth, tempEmpty.y * Game.board.frameHeight);\r\n    }\r\n\r\n    // add event listeners for char sterring\r\n\r\n    window.addEventListener('keydown', Game.onKey);\r\n    window.addEventListener('keyup', Game.onKey);\r\n\r\n    Game.animationLoop(); // launch game animation loop\r\n  },\r\n\r\n  onKey: (e) => {\r\n    if (e.keyCode >= 37 && e.keyCode <= 40 || e.keyCode == 32) { // use only arrows and space in game\r\n      e.preventDefault(); // turn off standard key actions\r\n      if (e.type == 'keydown' && !Game[`key_${e.keyCode}`]) { // when key has been pressed\r\n        Game[`key_${e.keyCode}`] = true; // set key to work\r\n        if (e.keyCode >= 37 && e.keyCode <= 40) { // if any arrow was pressed then make sure to disable previously pressed arrow\r\n          for (let i = 37; i <= 40; i++) {\r\n            if (i != e.keyCode) {\r\n              Game[`key_${i}`] = false;\r\n            }\r\n          }\r\n          Game.hero.updateState();\r\n        } else {\r\n          new Bomb(Game.hero.column, Game.hero.row);\r\n        }\r\n        Game.hero.updateState(); // launch update function when key is pressed (conditions above)\r\n      } else if (e.type == 'keyup') { // update state when key is released as well (char is standing)\r\n        Game[`key_${e.keyCode}`] = false;\r\n        Game.hero.updateState();\r\n      }\r\n    }\r\n  },\r\n\r\n  layout: () => {\r\n    VAR.H = window.innerHeight; // get window dimensions dynamically\r\n    VAR.W = window.innerWidth; // as above\r\n\r\n    VAR.scale = Math.max(1, Math.min(\r\n      Math.floor(VAR.H / (Game.board.frameWidth * Game.board.b[0].length)),\r\n      Math.floor(VAR.W / (Game.board.frameHeight * Game.board.b.length)),\r\n    ));\r\n\r\n    Game.canvas.width = Math.round(VAR.scale * Game.board.frameWidth * Game.board.b[0].length); // as above\r\n    Game.canvas.height = Math.round(VAR.scale * Game.board.frameHeight * Game.board.b.length); // set canvas dimensions based on window dimensions\r\n\r\n    Game.canvas.style[Modernizr.prefixed('transform')] = `translate(${Math.round((VAR.W - Game.canvas.width) / 2)}px, ${Math.round((VAR.H - Game.canvas.height) / 2)}px)`;\r\n\r\n    // 'translate('+Math.round((VAR.W-Game.canvas.width)/2) + 'px,' +Math.round((VAR.H-Game.canvas.height)/2)+'px)';\r\n    Game.ctx.imageSmoothingEnabled = false; // character pixels are super sharp\r\n    Game.ctx.mozImageSmoothingEnabled = false;\r\n    Game.ctx.oImageSmoothingEnabled = false;\r\n    Game.ctx.webkitImageSmoothingEnabled = false;\r\n  },\r\n\r\n  animationLoop: (time) => {\r\n    requestAnimationFrame(Game.animationLoop);\r\n    // limit fps to desired rate\r\n    if (time - VAR.lastTime >= 1000 / VAR.fps) {\r\n      VAR.lastTime = time;\r\n\r\n      Game.ctx.clearRect(0, 0, VAR.W, VAR.H);\r\n\r\n      Game.board.draw();\r\n\r\n      for (const i in Game.toDraw) {\r\n        Game.toDraw[i].draw();\r\n      }\r\n    }\r\n  },\r\n};\r\n"],"sourceRoot":""}